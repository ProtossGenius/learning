# 更好的设计

在这里,我会描述一些我认为的比较理想的设计.首先是我关于对系统好坏的衡量:好的系统应该容易变更,应该恪守DRY原则.

1. 容易变更的系统

* 容易替换-舍弃旧日的包袱

重构,这应该是程序员最怕听到的词语之一.我曾经听到过大神对别人说出"看开点,重构吧."这样激励人心的话语...

当没有耦合的时候,重构应该非常简单----只需要把这个模块换成一个新的模块,但现实并非如此.所以从一开始就应该假定这里会被重构,
编写易于重构的系统.

我认为比较稳妥的方式是采用接口化,使用CreateInterfaceFunction来创建实例,使用DeleteInterfaceFunction来删除实例,使用函数创建/删除
实例有四个好处:

首先在替换的使用不需要修改其他代码,只需要让CreateInterfaceFunction返回新的实例,DeleteInterfaceFunction删除新的实例就可以了.

第二个好处是容易使用智能指针来管理内存,避免内存泄漏.

第三个好处是可以使用dll,令CreateInterfaceFunction返回一个(void*)就可以强制转换成对应的接口实例,这可以作为一种热更新手段.

第四点是可以更好的做单元测试,而且定义良好的接口会让新人对项目的理解难度下降很多.另外这样可以减少破窗户的扩散,只要接口有完好的
注释,那么实现者即使代码写得很烂也不会增加别人对项目的理解难度.

当系统变得不够好的时候就应当重构,及时改掉弊病在长久来看是最节省时间的.

* 摒除细节-轻装上阵

"再多的天才也无法胜过对细节的专注".实际上刚刚提到的接口化的思路就是在摒除细节,只不过这里将更进一步.将细节挪出硬编码.
在进行设计的时候应当尽可能的思考如何设计一个规则引擎而不是设计if-else接龙.在时间确实短缺的情况下也应该留一个规则引擎接口
以便随时可以替换.

2. 容易开发的系统

* 自动化-让事情变得简单
在编码的层面上:当要向系统中添加一条协议需要做几件事?我工作中经历过的最坏的设计甚至需要手动编写协议类代码,
较好的设计也需要编写协议然后再去找到协议号文件手动添加到协议号Enum里.在我个人的项目里,最好的设计是SureMoonNet
的远程类调用,只需要编写类接口就可以用工具自动生成跨语言的服务器/客户端/协议/协议号等一系列的代码,其中协议处理方
面的工具可以自动维护协议号.

只要依赖使用者记住,就有犯错的倾向.以协议号为例,开发人员至少可能犯两个错误,可能会忘记添加协议号表,可能使用了重复的协议号.
再举一个例子,当使用git上传代码的时候,通常会要求先能够编译,然后能够通过单元测试,但只要开发者忘记了,那他就可能提交一份让所有
人无事可做的代码.我个人编写了一个整合了git命令的小工具,在每次上传的时候都会依次执行储存本地变更/拉代码/弹出本地
变更/执行make install/执行make test...这样一系列的操作,直到所有工作都运行完全才会将代码提到远程库.顺便一提,本项
目的目录也是通过这个工具进行维护的,每次提交都会更新目录.

* 开发者的工具

针对之前提到的系统之间的接口化问题,客户端和服务器要互相等待,且难于调试......实际上这不应该是个问题,在进行系统设计的时候应该
设计像这样的工具,一个客户端模拟器,能够自动化的做准备动作(如登录等),之后模拟客户端发包;一个服务器模拟器,在收到某个数据
包时回复一个定义好的数据包.这里以游戏开发为例分别举一种可能的实现方式(假设均以WEB作为界面):

客户端模拟器,第一个页面可以填写玩家的登录信息和一个登录按钮,留好默认值.登录成功之后进入第二个页面,里面有常用的GM命令,可以
初始化玩家.可以选择协议号,有一个文本框,在选择协议号之后应自动填入一个json模板,开发者可以通过这个发包.一个协议过滤器,可以
看到回包信息.

服务器模拟器,最好是服务器插件的形式,因为它应该有服务器完整的功能.可以在WEB界面中填入要拦截的协议号,然后填入回复协议的协议号
和json.

这两种实现起来都不很难但对开发者的效率提升会非常大.

* 创造容易复用的环境

"只有容易复用,人们才会去复用."复用有非常多的好处,但复用并不容易----尤其是可以复用的代码零散
在四面八方的时候.我认为应该有一个复用搜索工具方便开发者来寻找可以复用的代码.实际上复用最大的好处就是易于变更,当需要转变
实现的时候只需要修改一个地方,或者两个地方.修改的难度是O(1)而不是O(n),这非常重要.

## 在限制下选择更合适的设计

限制因素: 人员/时间/资源.

* 可替换性

对于长期项目来说,时间越是紧迫越应该考虑系统的可变更性和可重构性.这里是对开发及维护时时间复杂度的描述:

|行为|复杂度|描述|
|-|-|-|
|开发定义良好的接口系统|O(1)|也许会比随便复制粘贴慢一点,但只是在这个时间点慢一点,但也只是慢一点,通常甚至不会成为导致加班的元凶.|
|替换接口实现|O(1)|你应该只替换其生成方法和销毁方法|
|修改接口|O(n)|最坏的情况是删除接口方法和更改接口名,但这两种情况都不是特别应该出现,一个接口通常只应该对应一个实现类,所以就这方面而言实际上是O(1)|
|-|-|-|
|替换一个耦合类|O(n*m)|如果没有使用工厂方法和接口,你需要替换每一个使用到他的地方(n),而且你需要修改任何可能的受影响的地方,它的子类,与它紧密结合的类|
|修改一个耦合类|O(n*m)|由于不同的人对开发规范的理解不同,有些人可能会直接使用类中的成员变量,这种最坏的情况可能会导致m*n量级的变更,而相对较好的情况下也需要修改所有的子类|

可以看出设计接口本身不会成为开发的时间瓶颈,可替换性是第一个需要考虑的问题.

* 开发难度

评判可行性,根据接口系统来估算实现难度,通常接口越多表明实现起来越难,相似接口越多说明设计的越拙劣.

* 曳光弹

在子弹中插入荧光弹便可以随时知道偏离目标多远.接口化的一个好处是从一开始便已经得到了完整的系统,中将讲述开发时的
时间复杂度.可以构造空接口(为接口生成一个默认类,这样不会因为空指针导致宕机)随时确认距离目标有多远,可以从任何点入手开发,可以没有心里负担的为接口
提供低效但能快速完成的实现,随时可以优化.

