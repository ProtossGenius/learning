# 从需求开始的系统设计

1. 挖掘需求

我认为对需求的理解直接决定了系统的质量,往往提出需求的人并不是提出了最终需求,但仅仅是描述方式的不同就足以让开发人员开发出质量相差极大的产品.

如下对同一个需求的两种描述方式(来自程序员修炼之道-需求之坑)
* 只有人事部门和上级领导可以查看员工档案
这种描述方式很容易导致开发人员写出if-else接龙的代码,那是最坏的开发模式之一.
* 只有指定的人可以查看员工档案
通常开发人员会设定规则引擎.

纵上所述,我认为挖掘需求的过程主要是将细节从需求中剥离出去.

2. 设计接口

这里的接口并不是指Go或者Java中的接口,更是更加宽泛的把函数也算作了接口.可以认为是其他开发人员需要了解的最多的必要信息.

* 以算法为例
即使在设计一个算法,也应该预留接口,通常来说一个五十行的代码比五百行的代码更容易理解.
下面会以算法举一个例子(特别预留了一些bug)


```
//降序排序
void sort_descending(vector<int>& nums){
	// 排序,获得升序.
	for(int i = 0; i < nums; ++i){
		for(int j = i; j < nums; ++j){
			if(nums[i] > nums[j]){
				nums[i] = nums[j];
				nums[j] = nums[i];
			}
		}
	}
	// 做反转.
	int i = 0, j = nums.size() - 1;
	while(i < j){
		nums[i] = nums[j];
		nums[j] = nums[i];
	}
}

```


和一份我认为稍微好一点的代码


```
// 排序,获得升序.
void sort_ascending(vector<int>& nums){
	for(int i = 0; i < nums; ++i){
		for(int j = i; j < nums; ++j){
			if(nums[i] > nums[j]){
				nums[i] = nums[j];
				nums[j] = nums[i];
			}
		}
	}
}
// 反转数组
void reverse_array(vector<int>& nums){
	int i = 0, j = nums.size() - 1;
	while(i < j){
		nums[i] = nums[j];
		nums[j] = nums[i];
	}
}
//获得降序数组
void sort\_descending(vector<int>& nums){
	sort_ascending(nums);
	reverse_array(nums);
}
```


将具体的功能预留为接口有很多好处,诸如:容易复用,容易设计测试用例,随意可以替换算法.
虽然不太可能会有人写出这样的代码,不过再此仅以此为例.

在代码复核的时候很容易看到开发者的思路.在没有注释的情况下,下面的代码也会更加易懂.

当这份代码出现问题的时候,上面的代码可能需要仔细的理清逻辑,然后使用相对高深的调试技巧.

最重要的是单元测试,简单的事情安排单元测试一定要比复杂的事情安排单元测试容易,对下面的
实现方式来说我们可以对三个算法分别设计单元测试,从而更容易捉到bug.

* 以模块为例

当多个人共同开发一个功能的时候,通常做的第一件事就应该是预留接口,这样开发者们便不会互相
干扰,因为所有人都是这么做的,所以不再赘述.稍后会讲解我个人对此的理解.

* 以系统为例

以服务器系统和客户端系统为例,我目前经历的开发过程主要是服务器和客户端预留好了接口,然后
互相开发,等到两方同时结束之后,两个人进行联调.几乎所有的测试都是基于合理条件,若要测试边界
调节也许要客户端将边界条件放开,之后客户端好要记得把边界条件再改回去......

关于这样的问题,我会在在[更好的设计](better_design.md)里做更加深入的分析.

3. 实现

当做好这些事情之后便可以进入实现阶段了.

* 估算
时间复杂度/空间复杂度/实现难度

* 原型和曳光弹
对一个长期的项目来说,失败的越早成功的机会便越大.如果能够在PPT系统的时候发现问题,绝对比一个月
才发现问题要好.

* 编码
加好注释和单元测试,不要使用缩写,维护一个术语表,确保同样的事物都有唯一的表达.

